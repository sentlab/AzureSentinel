# Input bindings are passed in via param block.
param($Timer)

#Define global variables/parameters.
$ErrorActionPreference = 'Stop'
$lawResourceId = $env:LawResourceId
$dcrImmutableId = $env:DcrImmutableId
$dceUri = $env:DceUri
$uamiClientId = $env:UamiClientId
$transactionId = (New-Guid).Guid
$fullImport = $env:FullImport

#Function to create HTTP headers for REST API calls.
function Get-RequestHeaders {
    param ($Token)
    return @{"Authorization" = "Bearer $Token"; "Content-Type" = "application/json" }
}

#Function to get data via REST API and send to Azure Monitor.
function Import-Data {
    param ($SourceUri, $SourceToken, $Table, $DataSourceName, $JsonDepth, $AzureResources, $BatchSize, $DelayTime)
    $count = 1
    $startIndex = 0
    $queryString = ''
    $totalObjectsReceived = 0
    $totalConfigurationObjectsReceived = 0
    #Start loop to get data from source REST API and ingest into Azure Monitor.
    do {
        Write-Host ("Getting $DataSourceName, request #$count...")
        $startTime = Get-Date
        #Get data from source REST API.
        if ($DataSourceName -eq 'NIST CVE KB') {
            $response = Invoke-RestMethod -Method Get -Uri ($SourceUri + $queryString) -MaximumRetryCount 2 -RetryIntervalSec 31
            $content = $response.vulnerabilities | Select-Object -ExpandProperty cve
        }
        else {
            $response = Invoke-RestMethod -Method Get -Uri $SourceUri -Headers (Get-RequestHeaders -Token $SourceToken.Token) -MaximumRetryCount 2 -RetryIntervalSec 5
            $content = $response.value
        }
        if ($content.Count -eq 0) { 
            Write-Host "No objects were received."    
            return 
        }
        #Add TimeGenerated and transactionId properties to all records/objects received and rename id property if it exists because Azure Monitor reserves this column value.
        $content | Add-Member -NotePropertyName 'TimeGenerated' -NotePropertyValue (Get-Date -Format 'yyyy-MM-ddTHH:mm:ssZ' -AsUTC)
        $content | Add-Member -NotePropertyName 'transactionId' -NotePropertyValue $transactionId
        switch ($DataSourceName) {
            'MDVM Recommendations' {
                $content | Add-Member -MemberType AliasProperty -Name recId -Value id
            }
            'MDVM Secure Configurations by Device' {
                $content = $content | Where-Object { ($_.isApplicable -eq $true) -and ($_.IsCompliant -eq $false) }
                if ($null -ne $AzureResources) {
                    Write-Host "Looking up Azure Resource IDs..."
                    $content = Add-AzureResourceId -Data $content -AzureResources $AzureResources
                }
            }
            'MDVM Vulnerabilities by Device' {
                $content | Add-Member -MemberType AliasProperty -Name vulnId -Value id
                if ($null -ne $AzureResources) {
                    Write-Host "Looking up Azure Resource IDs..."
                    $content = Add-AzureResourceId -Data $content -AzureResources $AzureResources
                }
            }
            'MDVM CVE KB' {
                $content | Add-Member -MemberType AliasProperty -Name cveId -Value id
            }
            'NIST CVE KB' {
                $content | Add-Member -MemberType AliasProperty -Name cveId -Value id
                #Split off the configrations object and create a seperate array for these items so they can be ingested into their own Azure Monitor table.
                $configurations = New-Object System.Collections.ArrayList
                foreach ($item in $content | Where-Object configurations -ne $null) {
                    $configurationNumber = 0
                    foreach ($configuration in $item.configurations) {
                        $configurationNumber += 1
                        $nodes = $configuration | Select-Object -ExpandProperty nodes
                        foreach ($node in $nodes) {
                            $cpes = $node | Select-Object -ExpandProperty cpeMatch
                            $cpes | Add-Member -NotePropertyMembers @{
                                configurationNumber   = $configurationNumber
                                configurationOperator = $configuration.operator
                                configurationNegate   = $configuration.negate
                                nodeOperator          = $node.operator
                                nodeNegate            = $node.negate
                                cveId                 = $item.cveId
                                TimeGenerated         = $item.TimeGenerated
                                transactionId         = $transactionId
                            } -PassThru | Out-Null
                            foreach ($cpe in $cpes) {
                                $configurations.Add($cpe) | Out-Null
                            }
                        }
                    }
                    $item.PSObject.Properties.Remove('configurations')
                }
            }
        }
        #Update objects received variables.
        $objectsReceived = $content.Count
        $totalObjectsReceived += $objectsReceived

        #Send received data to Azure Monitor.
        Send-DataToAzureMonitor -Data $content -BatchSize $BatchSize -TableName "Custom-$Table" -JsonDepth $JsonDepth
        #If there was configuration data included in NIST data, send that to seperate table in Azure Monitor.
        if ($configurations.Count -ne 0) {
            $configurationObjectsReceived = $configurations.Count
            $totalConfigurationObjectsReceived += $configurationObjectsReceived
            Write-Host "Sending NIST Configurations KB..."
            Send-DataToAzureMonitor -Data $configurations -BatchSize 30000 -TableName "Custom-MDVMNISTConfigurations_CL" -JsonDepth $JsonDepth
        }
        else {
            $configurationObjectsReceived = 0
        }

        #Check if there is more data to be requested from source REST API and if so, update the next request URI.
        Write-Host ("Objects received and sent to Azure Monitor: $objectsReceived $($DataSourceName -eq 'NIST CVE KB' ? "(Configuration Objects: $configurationObjectsReceived)": '')")
        if ($DataSourceName -eq 'NIST CVE KB') {
            $startIndex += $response.resultsPerPage
            if ($SourceUri -like '*lastModStartDate*') { $queryString = "&startIndex=$startIndex" } else { $queryString = "?startIndex=$startIndex" }
            if ($startIndex -ge $response.totalResults) { $loopDone = $true }
        }
        else {
            $SourceUri = $response.'@odata.nextLink'
            if ($null -eq $SourceUri) { $loopDone = $true }
        }

        #Check the status of the async Azure Monitor ingestion jobs and write error if there are any unsuccessful jobs.
        Get-FailedJobs -Jobs $azMonJobs

        #Check how much time has elapsed since the last source API request and sleep if we are exceeding the API throttling/delay limits.
        $timeDiff = New-TimeSpan -Start $startTime -End (Get-Date)
        if ( $timeDiff.Milliseconds -lt $DelayTime -and $loopDone -ne $true) { Start-Sleep -Milliseconds ($DelayTime - $timeDiff.Milliseconds) } 
        
        $count += 1        
    } until ($loopDone -eq $true)
  
    #After all source API data has been processed, wait for any pending/running Azure Monitor ingestion jobs to complete.
    $pendingAzMonJobs = $azMonJobs | Where-Object { ($_.IsCompleted -eq $false) -or ($_.IsCompletedSuccessfully -eq $false) }
    while ($pendingAzMonJobs.Count -ne 0) {
        Start-Sleep -Seconds 1
        $secondsSpent += 1
        Get-FailedJobs -Jobs $pendingAzMonJobs
        $pendingAzMonJobs = $azMonJobs | Where-Object { ($_.IsCompleted -eq $false) -or ($_.IsCompletedSuccessfully -eq $false) }
        if ($secondsSpent -eq 120) { 
            Write-Error ("Azure Monitor async jobs have not completed after 2 minutes:" + ($pendingAzMonJobs | Where-Object { ($_.IsCompleted -eq $false) -or ($_.IsCompletedSuccessfully -eq $false) } | Select-Object Id, IsCompleted, Status, Exception | Format-Table | Out-String)) -ErrorAction Continue
            break 
        }
    }
    $azMonJobs.Clear()
    
    #Update total objects received metrics so we can compare later to total number of objects written to Azure Monitor and check for any mismatches.
    if ($tableStats | Where-Object TableName -eq $Table) {
        ($tableStats | Where-Object TableName -eq $Table).TotalObjectsReceived += $totalObjectsReceived
    }
    else {
        $tableStatsObject = New-Object psobject
        $tableStatsObject | Add-Member -NotePropertyName 'TableName' -NotePropertyValue $Table
        $tableStatsObject | Add-Member -NotePropertyName 'TotalObjectsReceived' -NotePropertyValue $totalObjectsReceived
        $tableStats.Add($tableStatsObject) | Out-Null
        if ($totalConfigurationObjectsReceived -gt 0) {
            $tableStatsObject = New-Object psobject
            $tableStatsObject | Add-Member -NotePropertyName 'TableName' -NotePropertyValue 'MDVMNISTConfigurations_CL'
            $tableStatsObject | Add-Member -NotePropertyName 'TotalObjectsReceived' -NotePropertyValue $totalConfigurationObjectsReceived
            $tableStats.Add($tableStatsObject) | Out-Null
        }
    }
}

#Function to split data into specified batch sizes (so we do not exceed the maximum body size) and send to Azure Monitor.
function Send-DataToAzureMonitor {
    param ($Data, $BatchSize, $TableName, $JsonDepth)
    $skip = 0
    do {
        $batchedData = $Data | Select-Object -Skip $skip | Select-Object -First $BatchSize
        $azMonJobs.Add($logIngestionClient.UploadAsync($dcrImmutableId, $TableName, ($batchedData | ConvertTo-Json -Depth $JsonDepth -AsArray))) | Out-Null
        $skip += $BatchSize
    } until (
        $skip -ge $Data.Count
    )
}

#Function to lookup and add Azure Resource ID based on MDVM device name.
function Add-AzureResourceId {
    param($Data, $AzureResources)
    foreach ($item in $Data) {
        if ($item.deviceName.IndexOf('.') -eq -1) { $azSearch = $AzureResources.($item.deviceName.ToLower) } else { $azSearch = $AzureResources.($item.deviceName.Substring(0, $item.deviceName.IndexOf('.')).ToLower()) }
        if ($null -ne $azSearch) {
            $item | Add-Member -NotePropertyName azResourceId -NotePropertyValue $azSearch.id
        }
        else {
            $item | Add-Member -NotePropertyName azResourceId -NotePropertyValue ''
        }
    }
    return $Data
}

#Function to check the status of the async Azure Monitor ingestion jobs and write error if there are any unsuccessful jobs.
function Get-FailedJobs {
    param ($Jobs)
    $failedJobs = $Jobs | Where-Object { ($_.IsCompleted -eq $true) -and ($_.IsCompletedSuccessfully -eq $false) }
    if ($failedJobs) { 
        foreach ($job in ($failedJobs)) { 
            Write-Error ("Error on Azure Monitor async job ID: " + $job.Id + ". Error Details: " + $job.Exception.message) -ErrorAction Continue
            $azMonJobs.Remove($job) 
        }
    }
}

#Add required .Net assemblies to handle the Azure Monitor ingestion.
Add-Type -Path .\GetMDVMData\libs\Azure.Monitor.Ingestion.dll
Add-Type -Path .\GetMDVMData\libs\Azure.Identity.dll

#Connect Azure Powershell via User Assigned Managed Identity.
Connect-AzAccount -Identity -AccountId $uamiClientID -Subscription $lawResourceId.Split('/')[2] | Out-Null

#Create Azure.Identity credential via User Assigned Managed Identity.
$credential = New-Object Azure.Identity.ManagedIdentityCredential($uamiClientId)
#Create LogsIngestionClient to handle sending data to Azure Monitor.
$logIngestionClient = New-Object Azure.Monitor.Ingestion.LogsIngestionClient($dceURI, $credential)

#Create array to hold object counts for each data source so we can compare to total records written later.
$tableStats = New-Object System.Collections.ArrayList
#Create array to hold Azure Monitor jobs status.
$azMonJobs = New-Object System.Collections.ArrayList

#Get Log Analytics workspace Id to be used later when querying data in the workspace.
$lawId = (Get-AzOperationalInsightsWorkspace -ResourceGroupName $lawResourceId.Split('/')[4] -Name $lawResourceId.Split('/')[8]).CustomerId

#Get OAuth token for Defender API.
$defenderToken = Get-AzAccessToken -ResourceUrl 'https://api.securitycenter.microsoft.com'

#Get Azure VM inventory and create hash table so we can quickly lookup and add Azure Resource ID to MDVM data later.
$azureVMsQuery = "resources
| where type in ('microsoft.compute/virtualmachines', 'microsoft.hybridcompute/machines')
| extend deviceName = properties.extended.instanceView.computerName
| extend deviceName = iif(deviceName == '', name, deviceName)
| project id = tolower(id), deviceName = tolower(deviceName)"
do {
    $response = Search-AzGraph -Query $azureVMsQuery -SkipToken $response.SkipToken -First 1000
    $azResources += $response
} until ($null -eq $response.SkipToken)
$azResources = $azResources | Group-Object -AsHashTable -Property deviceName

#Ingest MDVM Vulnerabilities by Device (Full).
$defenderUri = "https://api.securitycenter.microsoft.com/api/machines/SoftwareVulnerabilitiesByMachine"
Import-Data -SourceUri $defenderUri -SourceToken $defenderToken -DceUri $dceURI -DataSourceName 'MDVM Vulnerabilities by Device' `
    -JsonDepth 2 -Table 'MDVMVulnerabilitiesByDevice_CL' -AzureResources $azResources -BatchSize 15000 -DelayTime 500

#Ingest MDVM Recommendations (Full).
$defenderUri = 'https://api.securitycenter.microsoft.com/api/recommendations'
Import-Data -SourceUri $defenderUri -SourceToken $defenderToken -DataSourceName 'MDVM Recommendations' `
    -JsonDepth 2 -Table 'MDVMRecommendations_CL' -BatchSize 10000 -DelayTime 500

#Ingest MDVM Secure Configurations by Device (Full).
$defenderUri = 'https://api.securitycenter.microsoft.com/api/machines/SecureConfigurationsAssessmentByMachine'
Import-Data -SourceUri $defenderUri -SourceToken $defenderToken -DataSourceName 'MDVM Secure Configurations by Device' `
    -JsonDepth 2 -Table 'MDVMSecureConfigurationsByDevice_CL' -AzureResources $azResources -BatchSize 20000

#Ingest MDVM CVE KB (Incremental). 
$lawQuery = 'MDVMCVEKB_CL | order by todatetime(updatedOn) desc | take 1 | project updatedOn'
$mdvmKbLastUpdate = Invoke-AzOperationalInsightsQuery -WorkspaceId $lawId  -Query $lawQuery -Timespan 730D

$lawQuery = 'MDVMCVEKB_CL | summarize min(TimeGenerated) | project OldestRecord = format_timespan(now() - min_TimeGenerated, "d")'
$mdvmKBOldestRecord = Invoke-AzOperationalInsightsQuery -WorkspaceId $lawId -Query $lawQuery -Timespan 730D

$mdvmKbRetention = (Get-AzOperationalInsightsTable -ResourceGroupName ($lawResourceId.Split('/'))[4] -WorkspaceName ($lawResourceId.Split('/'))[8] -TableName 'MDVMCVEKB_CL' | Select-Object RetentionInDays)[0].RetentionInDays

if ($null -eq $mdvmKbLastUpdate.Results.updatedOn -Or $mdvmKBOldestRecord.Results.OldestRecord -ge ($mdvmKbRetention - 5) -Or $fullImport -eq 1) {
    $defenderUri = 'https://api.securitycenter.windows.com/api/Vulnerabilities'
}
else {
    $defenderUri = 'https://api.securitycenter.windows.com/api/Vulnerabilities?$filter=updatedOn+gt+' + $mdvmKbLastUpdate.Results.updatedOn
    Write-Host ("Checking for MDVM CVE KB data updated since " + $mdvmKbLastUpdate.Results.updatedOn + "...")
}

Import-Data -SourceUri $defenderUri -SourceToken $defenderToken -DataSourceName 'MDVM CVE KB' `
    -JsonDepth 2 -Table 'MDVMCVEKB_CL' -BatchSize 10000 -DelayTime 500

#Ingest NIST CVE KB data (Incremental).
$lawQuery = 'MDVMNISTCVEKB_CL | summarize LastTimeModified = max(lastModified) | project LastTimeModified'
$nistKbLastUpdate = Invoke-AzOperationalInsightsQuery -WorkspaceId $lawId -Query $lawQuery -Timespan 730D

$lawQuery = 'MDVMNISTCVEKB_CL | summarize min(TimeGenerated) | project OldestRecord = format_timespan(now() - min_TimeGenerated, "d")'
$nistKBOldestRecord = Invoke-AzOperationalInsightsQuery -WorkspaceId $lawId -Query $lawQuery -Timespan 730D

$nistKbRetention = (Get-AzOperationalInsightsTable -ResourceGroupName ($lawResourceId.Split('/'))[4] -WorkspaceName ($lawResourceId.Split('/'))[8] -TableName 'MDVMNISTCVEKB_CL' | Select-Object RetentionInDays)[0].RetentionInDays

if ($null -eq $nistKbLastUpdate.Results.LastTimeModified -Or $nistKBOldestRecord.Results.OldestRecord -ge ($nistKbRetention - 5) -Or $fullImport -eq 1) {
    $nistUri = 'https://services.nvd.nist.gov/rest/json/cves/2.0'
}
else {
    $lastModifiedTime = (([datetime]$nistKbLastUpdate.Results.LastTimeModified).AddMilliseconds(1)).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ss.fffZ')
    $nistUri = 'https://services.nvd.nist.gov/rest/json/cves/2.0/?lastModStartDate=' + $lastModifiedTime + '&lastModEndDate=' + (Get-Date -Format 'yyyy-MM-ddTHH:mm:ss.fffZ' -AsUTC)
    Write-Host ("Checking for NIST CVE KB data updated since " + $lastModifiedTime + "...")
}

Import-Data -SourceUri $nistUri -DataSourceName 'NIST CVE KB' -JsonDepth 8 -Table 'MDVMNISTCVEKB_CL' -BatchSize 2000 -DelayTime 7000

#Get count of total objects written to Azure Monitor and check for any mismatches against count of total objects received.
Write-Host "Waiting 3 minutes to allow for all data to get written to Azure Monitor before checking for any mismatches..."
Start-Sleep -Seconds 180
$lawQuery = "union withsource=MDVMTableName MDVM*
    | where transactionId == '$transactionId'
    | summarize Count = count() by MDVMTableName, transactionId"
$lawCounts = (Invoke-AzOperationalInsightsQuery -WorkspaceId $lawId -Query $lawQuery -Timespan 1D ).Results
foreach ($table in $tableStats) {
    $table | Add-Member -NotePropertyName TotalRecordsWrittenToAzureMonitor -NotePropertyValue (($lawCounts | Where-Object MDVMTableName -eq $table.TableName).Count)
    if (($table.TotalObjectsReceived -ne ($lawCounts | Where-Object MDVMTableName -eq $table.TableName).Count)) { $mismatch = $true } else { $mismatch = $false }
    $table | Add-Member -NotePropertyName Mismatch -NotePropertyValue $mismatch
}
#If there are any mismatches, write error, otherwise write success message.
if ($tableStats | Where-Object Mismatch -eq $true) {
    Write-Error -Message ("There is a mismatch between data received and written to Azure Monitor. Per table details are below:`n" + ($tableStats | Format-Table | Out-String))
}
else {
    Write-Host ("All data has been successfully written to Azure Monitor. Per table details are below: `n" + ($tableStats | Format-Table | Out-String))
}
